// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/gremlin"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/sourcenamespace"
)

// SourceName is the model entity for the SourceName schema.
type SourceName struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Commit holds the value of the "commit" field.
	Commit string `json:"commit,omitempty"`
	// Tag holds the value of the "tag" field.
	Tag string `json:"tag,omitempty"`
	// NamespaceID holds the value of the "namespace_id" field.
	NamespaceID int `json:"namespace_id,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the SourceNameQuery when eager-loading is set.
	Edges SourceNameEdges `json:"edges"`
}

// SourceNameEdges holds the relations/edges for other nodes in the graph.
type SourceNameEdges struct {
	// Namespace holds the value of the namespace edge.
	Namespace *SourceNamespace `json:"namespace,omitempty"`
	// Occurrences holds the value of the occurrences edge.
	Occurrences []*Occurrence `json:"occurrences,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// NamespaceOrErr returns the Namespace value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e SourceNameEdges) NamespaceOrErr() (*SourceNamespace, error) {
	if e.loadedTypes[0] {
		if e.Namespace == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: sourcenamespace.Label}
		}
		return e.Namespace, nil
	}
	return nil, &NotLoadedError{edge: "namespace"}
}

// OccurrencesOrErr returns the Occurrences value or an error if the edge
// was not loaded in eager-loading.
func (e SourceNameEdges) OccurrencesOrErr() ([]*Occurrence, error) {
	if e.loadedTypes[1] {
		return e.Occurrences, nil
	}
	return nil, &NotLoadedError{edge: "occurrences"}
}

// FromResponse scans the gremlin response data into SourceName.
func (sn *SourceName) FromResponse(res *gremlin.Response) error {
	vmap, err := res.ReadValueMap()
	if err != nil {
		return err
	}
	var scansn struct {
		ID          int    `json:"id,omitempty"`
		Name        string `json:"name,omitempty"`
		Commit      string `json:"commit,omitempty"`
		Tag         string `json:"tag,omitempty"`
		NamespaceID int    `json:"namespace_id,omitempty"`
	}
	if err := vmap.Decode(&scansn); err != nil {
		return err
	}
	sn.ID = scansn.ID
	sn.Name = scansn.Name
	sn.Commit = scansn.Commit
	sn.Tag = scansn.Tag
	sn.NamespaceID = scansn.NamespaceID
	return nil
}

// QueryNamespace queries the "namespace" edge of the SourceName entity.
func (sn *SourceName) QueryNamespace() *SourceNamespaceQuery {
	return NewSourceNameClient(sn.config).QueryNamespace(sn)
}

// QueryOccurrences queries the "occurrences" edge of the SourceName entity.
func (sn *SourceName) QueryOccurrences() *OccurrenceQuery {
	return NewSourceNameClient(sn.config).QueryOccurrences(sn)
}

// Update returns a builder for updating this SourceName.
// Note that you need to call SourceName.Unwrap() before calling this method if this SourceName
// was returned from a transaction, and the transaction was committed or rolled back.
func (sn *SourceName) Update() *SourceNameUpdateOne {
	return NewSourceNameClient(sn.config).UpdateOne(sn)
}

// Unwrap unwraps the SourceName entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (sn *SourceName) Unwrap() *SourceName {
	_tx, ok := sn.config.driver.(*txDriver)
	if !ok {
		panic("ent: SourceName is not a transactional entity")
	}
	sn.config.driver = _tx.drv
	return sn
}

// String implements the fmt.Stringer.
func (sn *SourceName) String() string {
	var builder strings.Builder
	builder.WriteString("SourceName(")
	builder.WriteString(fmt.Sprintf("id=%v, ", sn.ID))
	builder.WriteString("name=")
	builder.WriteString(sn.Name)
	builder.WriteString(", ")
	builder.WriteString("commit=")
	builder.WriteString(sn.Commit)
	builder.WriteString(", ")
	builder.WriteString("tag=")
	builder.WriteString(sn.Tag)
	builder.WriteString(", ")
	builder.WriteString("namespace_id=")
	builder.WriteString(fmt.Sprintf("%v", sn.NamespaceID))
	builder.WriteByte(')')
	return builder.String()
}

// SourceNames is a parsable slice of SourceName.
type SourceNames []*SourceName

// FromResponse scans the gremlin response data into SourceNames.
func (sn *SourceNames) FromResponse(res *gremlin.Response) error {
	vmap, err := res.ReadValueMap()
	if err != nil {
		return err
	}
	var scansn []struct {
		ID          int    `json:"id,omitempty"`
		Name        string `json:"name,omitempty"`
		Commit      string `json:"commit,omitempty"`
		Tag         string `json:"tag,omitempty"`
		NamespaceID int    `json:"namespace_id,omitempty"`
	}
	if err := vmap.Decode(&scansn); err != nil {
		return err
	}
	for _, v := range scansn {
		node := &SourceName{ID: v.ID}
		node.Name = v.Name
		node.Commit = v.Commit
		node.Tag = v.Tag
		node.NamespaceID = v.NamespaceID
		*sn = append(*sn, node)
	}
	return nil
}
