// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/gremlin"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/packagenamespace"
)

// PackageName is the model entity for the PackageName schema.
type PackageName struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// NamespaceID holds the value of the "namespace_id" field.
	NamespaceID int `json:"namespace_id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the PackageNameQuery when eager-loading is set.
	Edges PackageNameEdges `json:"edges"`
}

// PackageNameEdges holds the relations/edges for other nodes in the graph.
type PackageNameEdges struct {
	// Namespace holds the value of the namespace edge.
	Namespace *PackageNamespace `json:"namespace,omitempty"`
	// Versions holds the value of the versions edge.
	Versions []*PackageVersion `json:"versions,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// NamespaceOrErr returns the Namespace value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PackageNameEdges) NamespaceOrErr() (*PackageNamespace, error) {
	if e.loadedTypes[0] {
		if e.Namespace == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: packagenamespace.Label}
		}
		return e.Namespace, nil
	}
	return nil, &NotLoadedError{edge: "namespace"}
}

// VersionsOrErr returns the Versions value or an error if the edge
// was not loaded in eager-loading.
func (e PackageNameEdges) VersionsOrErr() ([]*PackageVersion, error) {
	if e.loadedTypes[1] {
		return e.Versions, nil
	}
	return nil, &NotLoadedError{edge: "versions"}
}

// FromResponse scans the gremlin response data into PackageName.
func (pn *PackageName) FromResponse(res *gremlin.Response) error {
	vmap, err := res.ReadValueMap()
	if err != nil {
		return err
	}
	var scanpn struct {
		ID          int    `json:"id,omitempty"`
		NamespaceID int    `json:"namespace_id,omitempty"`
		Name        string `json:"name,omitempty"`
	}
	if err := vmap.Decode(&scanpn); err != nil {
		return err
	}
	pn.ID = scanpn.ID
	pn.NamespaceID = scanpn.NamespaceID
	pn.Name = scanpn.Name
	return nil
}

// QueryNamespace queries the "namespace" edge of the PackageName entity.
func (pn *PackageName) QueryNamespace() *PackageNamespaceQuery {
	return NewPackageNameClient(pn.config).QueryNamespace(pn)
}

// QueryVersions queries the "versions" edge of the PackageName entity.
func (pn *PackageName) QueryVersions() *PackageVersionQuery {
	return NewPackageNameClient(pn.config).QueryVersions(pn)
}

// Update returns a builder for updating this PackageName.
// Note that you need to call PackageName.Unwrap() before calling this method if this PackageName
// was returned from a transaction, and the transaction was committed or rolled back.
func (pn *PackageName) Update() *PackageNameUpdateOne {
	return NewPackageNameClient(pn.config).UpdateOne(pn)
}

// Unwrap unwraps the PackageName entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pn *PackageName) Unwrap() *PackageName {
	_tx, ok := pn.config.driver.(*txDriver)
	if !ok {
		panic("ent: PackageName is not a transactional entity")
	}
	pn.config.driver = _tx.drv
	return pn
}

// String implements the fmt.Stringer.
func (pn *PackageName) String() string {
	var builder strings.Builder
	builder.WriteString("PackageName(")
	builder.WriteString(fmt.Sprintf("id=%v, ", pn.ID))
	builder.WriteString("namespace_id=")
	builder.WriteString(fmt.Sprintf("%v", pn.NamespaceID))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(pn.Name)
	builder.WriteByte(')')
	return builder.String()
}

// PackageNames is a parsable slice of PackageName.
type PackageNames []*PackageName

// FromResponse scans the gremlin response data into PackageNames.
func (pn *PackageNames) FromResponse(res *gremlin.Response) error {
	vmap, err := res.ReadValueMap()
	if err != nil {
		return err
	}
	var scanpn []struct {
		ID          int    `json:"id,omitempty"`
		NamespaceID int    `json:"namespace_id,omitempty"`
		Name        string `json:"name,omitempty"`
	}
	if err := vmap.Decode(&scanpn); err != nil {
		return err
	}
	for _, v := range scanpn {
		node := &PackageName{ID: v.ID}
		node.NamespaceID = v.NamespaceID
		node.Name = v.Name
		*pn = append(*pn, node)
	}
	return nil
}
