// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/gremlin"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/artifact"
	"github.com/guacsec/guac/pkg/assembler/backends/ent/builder"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

// SLSAAttestation is the model entity for the SLSAAttestation schema.
type SLSAAttestation struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Type of the builder
	BuildType string `json:"build_type,omitempty"`
	// ID of the builder
	BuiltByID int `json:"built_by_id,omitempty"`
	// ID of the subject artifact
	SubjectID int `json:"subject_id,omitempty"`
	// Individual predicates found in the attestation
	SlsaPredicate []*model.SLSAPredicate `json:"slsa_predicate,omitempty"`
	// Version of the SLSA predicate
	SlsaVersion string `json:"slsa_version,omitempty"`
	// Timestamp of build start time
	StartedOn *time.Time `json:"started_on,omitempty"`
	// Timestamp of build end time
	FinishedOn *time.Time `json:"finished_on,omitempty"`
	// Document from which this attestation is generated from
	Origin string `json:"origin,omitempty"`
	// GUAC collector for the document
	Collector string `json:"collector,omitempty"`
	// Hash of the artifacts that was built
	BuiltFromHash string `json:"built_from_hash,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the SLSAAttestationQuery when eager-loading is set.
	Edges SLSAAttestationEdges `json:"edges"`
}

// SLSAAttestationEdges holds the relations/edges for other nodes in the graph.
type SLSAAttestationEdges struct {
	// BuiltFrom holds the value of the built_from edge.
	BuiltFrom []*Artifact `json:"built_from,omitempty"`
	// BuiltBy holds the value of the built_by edge.
	BuiltBy *Builder `json:"built_by,omitempty"`
	// Subject holds the value of the subject edge.
	Subject *Artifact `json:"subject,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// BuiltFromOrErr returns the BuiltFrom value or an error if the edge
// was not loaded in eager-loading.
func (e SLSAAttestationEdges) BuiltFromOrErr() ([]*Artifact, error) {
	if e.loadedTypes[0] {
		return e.BuiltFrom, nil
	}
	return nil, &NotLoadedError{edge: "built_from"}
}

// BuiltByOrErr returns the BuiltBy value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e SLSAAttestationEdges) BuiltByOrErr() (*Builder, error) {
	if e.loadedTypes[1] {
		if e.BuiltBy == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: builder.Label}
		}
		return e.BuiltBy, nil
	}
	return nil, &NotLoadedError{edge: "built_by"}
}

// SubjectOrErr returns the Subject value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e SLSAAttestationEdges) SubjectOrErr() (*Artifact, error) {
	if e.loadedTypes[2] {
		if e.Subject == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: artifact.Label}
		}
		return e.Subject, nil
	}
	return nil, &NotLoadedError{edge: "subject"}
}

// FromResponse scans the gremlin response data into SLSAAttestation.
func (sa *SLSAAttestation) FromResponse(res *gremlin.Response) error {
	vmap, err := res.ReadValueMap()
	if err != nil {
		return err
	}
	var scansa struct {
		ID            int                    `json:"id,omitempty"`
		BuildType     string                 `json:"build_type,omitempty"`
		BuiltByID     int                    `json:"built_by_id,omitempty"`
		SubjectID     int                    `json:"subject_id,omitempty"`
		SlsaPredicate []*model.SLSAPredicate `json:"slsa_predicate,omitempty"`
		SlsaVersion   string                 `json:"slsa_version,omitempty"`
		StartedOn     int64                  `json:"started_on,omitempty"`
		FinishedOn    int64                  `json:"finished_on,omitempty"`
		Origin        string                 `json:"origin,omitempty"`
		Collector     string                 `json:"collector,omitempty"`
		BuiltFromHash string                 `json:"built_from_hash,omitempty"`
	}
	if err := vmap.Decode(&scansa); err != nil {
		return err
	}
	sa.ID = scansa.ID
	sa.BuildType = scansa.BuildType
	sa.BuiltByID = scansa.BuiltByID
	sa.SubjectID = scansa.SubjectID
	sa.SlsaPredicate = scansa.SlsaPredicate
	sa.SlsaVersion = scansa.SlsaVersion
	v5 := time.Unix(0, scansa.StartedOn)
	sa.StartedOn = &v5
	v6 := time.Unix(0, scansa.FinishedOn)
	sa.FinishedOn = &v6
	sa.Origin = scansa.Origin
	sa.Collector = scansa.Collector
	sa.BuiltFromHash = scansa.BuiltFromHash
	return nil
}

// QueryBuiltFrom queries the "built_from" edge of the SLSAAttestation entity.
func (sa *SLSAAttestation) QueryBuiltFrom() *ArtifactQuery {
	return NewSLSAAttestationClient(sa.config).QueryBuiltFrom(sa)
}

// QueryBuiltBy queries the "built_by" edge of the SLSAAttestation entity.
func (sa *SLSAAttestation) QueryBuiltBy() *BuilderQuery {
	return NewSLSAAttestationClient(sa.config).QueryBuiltBy(sa)
}

// QuerySubject queries the "subject" edge of the SLSAAttestation entity.
func (sa *SLSAAttestation) QuerySubject() *ArtifactQuery {
	return NewSLSAAttestationClient(sa.config).QuerySubject(sa)
}

// Update returns a builder for updating this SLSAAttestation.
// Note that you need to call SLSAAttestation.Unwrap() before calling this method if this SLSAAttestation
// was returned from a transaction, and the transaction was committed or rolled back.
func (sa *SLSAAttestation) Update() *SLSAAttestationUpdateOne {
	return NewSLSAAttestationClient(sa.config).UpdateOne(sa)
}

// Unwrap unwraps the SLSAAttestation entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (sa *SLSAAttestation) Unwrap() *SLSAAttestation {
	_tx, ok := sa.config.driver.(*txDriver)
	if !ok {
		panic("ent: SLSAAttestation is not a transactional entity")
	}
	sa.config.driver = _tx.drv
	return sa
}

// String implements the fmt.Stringer.
func (sa *SLSAAttestation) String() string {
	var builder strings.Builder
	builder.WriteString("SLSAAttestation(")
	builder.WriteString(fmt.Sprintf("id=%v, ", sa.ID))
	builder.WriteString("build_type=")
	builder.WriteString(sa.BuildType)
	builder.WriteString(", ")
	builder.WriteString("built_by_id=")
	builder.WriteString(fmt.Sprintf("%v", sa.BuiltByID))
	builder.WriteString(", ")
	builder.WriteString("subject_id=")
	builder.WriteString(fmt.Sprintf("%v", sa.SubjectID))
	builder.WriteString(", ")
	builder.WriteString("slsa_predicate=")
	builder.WriteString(fmt.Sprintf("%v", sa.SlsaPredicate))
	builder.WriteString(", ")
	builder.WriteString("slsa_version=")
	builder.WriteString(sa.SlsaVersion)
	builder.WriteString(", ")
	if v := sa.StartedOn; v != nil {
		builder.WriteString("started_on=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := sa.FinishedOn; v != nil {
		builder.WriteString("finished_on=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("origin=")
	builder.WriteString(sa.Origin)
	builder.WriteString(", ")
	builder.WriteString("collector=")
	builder.WriteString(sa.Collector)
	builder.WriteString(", ")
	builder.WriteString("built_from_hash=")
	builder.WriteString(sa.BuiltFromHash)
	builder.WriteByte(')')
	return builder.String()
}

// SLSAAttestations is a parsable slice of SLSAAttestation.
type SLSAAttestations []*SLSAAttestation

// FromResponse scans the gremlin response data into SLSAAttestations.
func (sa *SLSAAttestations) FromResponse(res *gremlin.Response) error {
	vmap, err := res.ReadValueMap()
	if err != nil {
		return err
	}
	var scansa []struct {
		ID            int                    `json:"id,omitempty"`
		BuildType     string                 `json:"build_type,omitempty"`
		BuiltByID     int                    `json:"built_by_id,omitempty"`
		SubjectID     int                    `json:"subject_id,omitempty"`
		SlsaPredicate []*model.SLSAPredicate `json:"slsa_predicate,omitempty"`
		SlsaVersion   string                 `json:"slsa_version,omitempty"`
		StartedOn     int64                  `json:"started_on,omitempty"`
		FinishedOn    int64                  `json:"finished_on,omitempty"`
		Origin        string                 `json:"origin,omitempty"`
		Collector     string                 `json:"collector,omitempty"`
		BuiltFromHash string                 `json:"built_from_hash,omitempty"`
	}
	if err := vmap.Decode(&scansa); err != nil {
		return err
	}
	for _, v := range scansa {
		node := &SLSAAttestation{ID: v.ID}
		node.BuildType = v.BuildType
		node.BuiltByID = v.BuiltByID
		node.SubjectID = v.SubjectID
		node.SlsaPredicate = v.SlsaPredicate
		node.SlsaVersion = v.SlsaVersion
		v5 := time.Unix(0, v.StartedOn)
		node.StartedOn = &v5
		v6 := time.Unix(0, v.FinishedOn)
		node.FinishedOn = &v6
		node.Origin = v.Origin
		node.Collector = v.Collector
		node.BuiltFromHash = v.BuiltFromHash
		*sa = append(*sa, node)
	}
	return nil
}
