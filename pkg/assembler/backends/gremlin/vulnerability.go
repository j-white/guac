package gremlin

import (
	"context"
	"github.com/guacsec/guac/pkg/assembler/graphql/model"
)

const (
	Vulnerability Label = "vulnerability"
)

func createUpsertForVulnerability(vuln *model.VulnerabilityInputSpec) *gremlinQueryBuilder[*model.Vulnerability] {
	return createUpsertForVertex[*model.Vulnerability](Vulnerability).
		withPropStringToLower(typeStr, &vuln.Type).
		withPropStringToLower(vulnerabilityId, &vuln.VulnerabilityID).
		withMapper(getVulnerabilityFromVertex)
}

func getVulnerabilityFromVertex(result *gremlinQueryResult) (*model.Vulnerability, error) {
	vulnerability := &model.Vulnerability{
		ID:   result.vertexId,
		Type: result.vertex[typeStr].(string),
		VulnerabilityIDs: []*model.VulnerabilityID{{
			ID:              "", // TODO
			VulnerabilityID: result.vertex[vulnerabilityId].(string)},
		},
	}
	return vulnerability, nil
}

func (c *gremlinClient) IngestVulnerability(ctx context.Context, vuln model.VulnerabilityInputSpec) (*model.Vulnerability, error) {
	return createUpsertForVulnerability(&vuln).upsert(c)
}

func (c *gremlinClient) IngestVulnerabilities(ctx context.Context, vulns []*model.VulnerabilityInputSpec) ([]*model.Vulnerability, error) {
	var queries []*gremlinQueryBuilder[*model.Vulnerability]
	for _, vulnerability := range vulns {
		queries = append(queries, createUpsertForVulnerability(vulnerability))
	}

	return createBulkUpsertForVertex[*model.Vulnerability](Vulnerability).
		withQueries(queries).
		upsertBulk(c)
}

func (c *gremlinClient) Vulnerabilities(ctx context.Context, vulnSpec *model.VulnerabilitySpec) ([]*model.Vulnerability, error) {
	q := createQueryForVertex[*model.Vulnerability](Vulnerability).
		withId(vulnSpec.ID).
		withPropString(typeStr, vulnSpec.Type).
		withPropString(vulnerabilityId, vulnSpec.VulnerabilityID).
		withMapper(getVulnerabilityFromVertex)
	return q.findAllEdges(c)
}
